# **为什么需要数据库设计**



我们在设计数据表的时候,要考虑很多问题。

比如:用户都需要什么数据？需要在数据表中保存哪些数据？如何保证数据表中数据的 正确性，当插入、删除、更新的时候该进行怎样的 约束检查？如何降低数据表的 数据冗余度，保证数据表不会因为用户量的增长而迅速扩张？如何让负责数据库维护的人员 更方便 地使用数据库？使用数据库的应用场景也各不相同，可以说针对不同的情况，设计出来的数据表可能千差万别。



现实情况中，面临的场景：

当数据库运行了一段时间之后,我们才发现数据表设计的有问题。重新调整数据表的结构,就需要做数据迁移,还有可能影响程序的业务逻辑,以及网站正常的访问。



如果是糟糕的数据库设计可能会造成以下问题：

数据冗余、信息重复，存储空间浪费数据更新、插入、删除的异常无法正确表示信息丢失有效信息程序性能差

良好的数据库设计则有以下优点:

节省数据的存储空间

能够保证数据的完整性

方便进行数据库应用系统的开发

总之,开始设置数据库的时候,我们就需要重视数据表的设计。为了建立冗余较小、结构合理的数据库,设计数据库时必须遵循一定的规则

# **范 式**

## **范式简介**

**在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。**可以理解为，一张数据表的设计结构需要满足的某种设计标准的 级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。

 

## **范式都包括哪些**

目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。

数据库的范式设计越高阶,冗余度就越低,同时高阶的范式一定符合低阶范式的要求,满足最低要求的范式是第一范式(1NF) 。在第一范式的基础上进一步满足更多规范要求的称为第二范式(2NF) ,其余范式以次类推。

一般来说,在关系型数据库设计中,最高也就遵循到BCNF ,普遍还是3NF 。但也不绝对,有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是反规范化。

![image-20240618094459777](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191349972.png)

## **键和相关属性的概念**

范式的定义会使用到主键和候选键,数据库中的键(Key)由一个或者多个属性组成。数据表中常用的几种键和属性的定义：

超键：能唯一标识元组的属性集叫做超键。

候选键：如果超键不包括多余的属性，那么这个超键就是候选键。

主键：用户可以从候选键中选择一个作为主键。

外键：如果数据表 R1 中的某属性集不是 R1 的主键，而是另一个数据表 R2的主键，那么这个属性集就是数据表R1的外键。

主属性：包含在任一候选键中的属性称为主属性。非主属性:与主属性相对,指的是不包含在任何一个候选键中的属性。

这里有两个表：

球员表(player) ：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号

球队表(team) ：球队编号 | 主教练 | 球队所在地**字段名称** 

**字段类型** 

**是否是主键** 

**说明**

id 

INT 

是 

主键id

username 

VARCHAR(30) 

否 

用户名

password 

VARCHAR(50) 

否 

密码

user_info 

VARCHAR(255) 

否 

用户信息 (包含真实姓名、电话、住址)

超键 ：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。

候选键 ：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。

主键 ：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。

外键 ：球员表中的球队编号。

主属性 、 非主属性 ：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性

## **第一范式(1st NF)**

第一范式主要是确保数据表中每个字段的值必须具有 原子性，也就是说数据表中每个字段的值为 不可再次拆分的最小数据单元。我们在设计某个字段的时候,对于字段X来说,不能把字段X拆分成字段X-1和字段X-2。事实上,任何的DBMS都会满足第一范式的要求,不会将字段进行拆分。

### 举例1：

假设一家公司要存储员工的姓名和联系方式。它创建一个如下表：

![image-20240618095323353](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191349372.png)

该表不符合 1NF ，因为规则说“表的每个属性必须具有原子（单个）值”，lisi和zhaoliu员工的emp_mobile 值违反了该规则。为了使表符合 1NF ，我们应该有如下表数据：

![image-20240618095339611](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191349916.png)

举例2：

user 表的设计不符合第一范式

![image-20240618095400262](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191349873.png)

其中，user_info字段为用户信息，可以进一步拆分成更小粒度的字段，不符合数据库设计对第一范式的要求。将user_info拆分后如下：

![image-20240618095416712](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191349021.png)

举例3：

属性的原子性是 主观的 。例如，Employees关系中雇员姓名应当使用1个（fullname）、2个（firstname和lastname）还是3个（firstname、middlename和lastname）属性表示呢？答案取决于应用程序。如果应用程序需要分别处理雇员的姓名部分（如：用于搜索目的），则有必要把它们分开。否则，不需要。

表1：

![image-20240618095613670](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191349932.png)

表2：

![image-20240618095629559](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191349549.png)

## **第二范式(2nd NF)**

举例1：

成绩表 （学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课程号也不能决定成绩，所以“（学号，课程号）→成绩”就是 完全依赖关系 。

举例2：

比赛表 player_game ，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键（或主键）来决定如下的关系：

```sql
(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)
```

但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：

```
(球员编号) → (姓名，年龄)
(比赛编号) → (比赛时间, 比赛场地)
```

对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？

\1. 数据冗余 ：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。

\2. 插入异常 ：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没法插入。

\3. 删除异常 ：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删除掉。

\4. 更新异常 ：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调整，否则就会出现一场比赛时间不同的情况。

为了避免出现上述的情况，我们可以把球员比赛表设计为下面的三张表。

![image-20240618095825040](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191349009.png)

这样的话，每张数据表都符合第二范式，也就避免了异常情况的发生。

1NF 告诉我们字段属性需要是原子性的，而 2NF 告诉我们一张表就是一个独立的对象，一张表只表达一个意思。

举例3：

定义了一个名为 Orders 的关系，表示订单和订单行的信息

![image-20240618095935101](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191350191.png)

违反了第二范式，因为有非主键属性仅依赖于候选键（或主键）的一部分。例如，可以仅通过orderid找到订单的 orderdate，以及 customerid 和 companyname，而没有必要再去使用productid。

Orders表和OrderDetails表如下，此时符合第二范式

![image-20240618095958726](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191350765.png)

##  第三范式(3rd NF)

举例1：

部门信息表 ：每个部门有部门编号（dept_id）、部门名称、部门简介等信息。

员工信息表 ：每个员工有员工编号、姓名、部门编号。列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。

如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余

举例2：

![image-20240618100056693](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191350425.png)

商品类别名称依赖于商品类别编号，不符合第三范式。

表1：符合第三范式的 商品类别表 的设计

![image-20240618100115908](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191350520.png)

表2：符合第三范式的 商品表 的设计

![image-20240618100126811](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191350861.png)

商品表goods通过商品类别id字段（category_id）与商品类别表goods_category进行关联。

举例3：

球员player表 ：球员编号、姓名、球队名称和球队主教练。现在，我们把属性之间的依赖关系画出来，如下图所示

![image-20240618100202504](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191350699.png)

你能看到球员编号决定了球队名称，同时球队名称决定了球队主教练，非主属性球队主教练就会传递依赖于球员编号，因此不符合 3NF 的要求。

如果要达到 3NF 的要求，需要把数据表拆成下面这样：

![image-20240618100219204](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191350564.png)

举例4：

修改第二范式中的举例3。

此时的Orders关系包含 orderid、orderdate、customerid 和 companyname 属性，主键定义为 orderid。customerid 和companyname均依赖于主键——orderid。例如，你需要通过orderid主键来查找代表订单中客户的customerid，同样，你需要通过 orderid 主键查找订单中客户的公司名称（companyname）。然而， customerid和companyname也是互相依靠的。为满足第三范式，可以改写如下：

![image-20240618100239737](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191354872.png)

符合3NF后的数据模型通俗地讲，2NF和3NF通常以这句话概括：“每个非键属性依赖于键，依赖于整个键，并且除了键别无他物”。

# **反范式化**

## **概述**

有的时候不能简单按照规范要求设计数据表，因为有的数据看似冗余，其实对业务来说十分重要。这个时候，我们就要遵循 业务优先的原则，首先满足业务需求，再尽量减少冗余。如果数据库中的数据量比较大,系统的UV和PV访问频次比较高,则完全按照MySQL的三大范式设计数据表,读数据时会产生大量的关联查询，在一定程度上会影响数据库的读性能。如果我们想对查询效率进行优化，反范式优化 也是一种优化思路。此时，可以通过在数据表中 增加冗余字段 来提高数据库的读性能。

**规范化** **vs** **性能**

\1. 为满足某种商业目标 , 数据库性能比规范化数据库更重要

\2. 在数据规范化的同时 , 要综合考虑数据库的性能

\3. 通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间

\4. 通过在给定的表中插入计算列，以方便查询

## **应用举例**

**举例**1：

员工的信息存储在 employees 表 中，部门信息存储在 departments 表 中。通过 employees 表中的department_id字段与 departments 表建立关联关系。如果要查询一个员工所在部门的名称：

```sql
select employee_id,department_name
from employees e join departments d
on e.department_id = d.department_id;
```

如果经常需要进行这个操作，连接查询就会浪费很多时间。可以在 employees 表中增加一个冗余字段department_name，这样就不用每次都进行连接操作了。

**举例****2****：**

反范式化的 goods商品信息表 设计如下：

![image-20240618100717677](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191353872.png)

**举例****3****：** 我们有 2 个表，分别是 商品流水表（atguigu.trans ）和 商品信息表

（atguigu.goodsinfo） 。商品流水表里有 400 万条流水记录，商品信息表里有 2000 条商品记录。

商品流水表：

![image-20240618100737510](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191353235.png)

商品信息表：

![image-20240618100751310](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191353294.png)

**举例****4****：**

课程评论表 class_comment ，对应的字段名称及含义如下：

![image-20240618100804717](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191353460.png)

在实际应用中，我们在显示课程评论的时候，通常会显示这个学生的昵称，而不是学生 ID，因此当我们

想要查询某个课程的前 1000 条评论时，需要关联 class_comment 和 student这两张表来进行查询。

**实验数据：模拟两张百万量级的数据表**

为了更好地进行 SQL 优化实验，我们需要给学生表和课程评论表随机模拟出百万量级的数据。我们可以

通过存储过程来实现模拟数据。

**反范式优化实验对比**

如果我们想要查询课程 ID 为 10001 的前 1000 条评论，需要写成下面这样：

```sql
SELECT p.comment_text, p.comment_time, stu.stu_name
FROM class_comment AS p LEFT JOIN student AS stu
ON p.stu_id = stu.stu_id
WHERE p.class_id = 10001
ORDER BY p.comment_id DESC
LIMIT 1000;
```

运行结果（1000 条数据行）

![image-20240618100841115](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191353623.png)

运行时长为 0.395 秒，对于网站的响应来说，这已经很慢了，用户体验会非常差。

如果我们想要提升查询的效率，可以允许适当的数据冗余，也就是在商品评论表中增加用户昵称字段，在 class_comment 数据表的基础上增加 stu_name 字段，就得到了 class_comment2 数据表。

这样一来，只需单表查询就可以得到数据集结果：

```sql
SELECT comment_text, comment_time, stu_name
FROM class_comment2
WHERE class_id = 10001
ORDER BY class_id DESC LIMIT 1000;
```

运行结果（1000 条数据）：

![image-20240618100911307](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191353225.png)

优化之后只需要扫描一次聚集索引即可，运行时间为 0.039 秒，查询时间是之前的 1/10。 你能看到，在数据量大的情况下，查询效率会有显著的提升

### **反范式的新问题**

存储 空间变大 了

一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则 数据不一致

若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常 消耗系统资源

在 数据量小 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加 复杂

## **反范式的适用场景**

当冗余信息有价值或者能 大幅度提高查询效率 的时候，我们才会采取反范式的优化。

**1.** **增加冗余字段的建议**

**2.** **历史快照、历史数据的需要**

在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的 订单收货信息 都属于 历史快照 ，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。

反范式优化也常用在 数据仓库 的设计中，因为数据仓库通常 存储历史数据 ，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。

# BCNF(巴斯范式)

**1.** **案例**

我们分析如下表的范式情况：

![image-20240618101021459](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191353825.png)

在这个表中，一个仓库只有一个管理员，同时一个管理员也只管理一个仓库。我们先来梳理下这些属性之间的依赖关系。

仓库名决定了管理员，管理员也决定了仓库名，同时（仓库名，物品名）的属性集合可以决定数量这个属性。这样，我们就可以找到数据表的候选键。

候选键 ：是（管理员，物品名）和（仓库名，物品名），然后我们从候选键中选择一个作为 主键 ，比如（仓库名，物品名）。

主属性 ：包含在任一候选键中的属性，也就是仓库名，管理员和物品名。

非主属性 ：数量这个属性

**是否符合三范式**

如何判断一张表的范式呢？我们需要根据范式的等级，从低到高来进行判断。

首先，数据表每个属性都是原子性的，符合 1NF 的要求；

其次，数据表中非主属性”数量“都与候选键全部依赖，（仓库名，物品名）决定数量，（管理员，物品名）决定数量。因此，数据表符合 2NF 的要求；

最后，数据表中的非主属性，不传递依赖于候选键。因此符合 3NF 的要求。

**存在的问题**

既然数据表已经符合了 3NF 的要求，是不是就不存在问题了呢？我们来看下面的情况：

\1. 增加一个仓库，但是还没有存放任何物品。根据数据表实体完整性的要求，主键不能有空值，因此会出现 插入异常 ；

\2. 如果仓库更换了管理员，我们就可能会 修改数据表中的多条记录 ；

\3. 如果仓库里的商品都卖空了，那么此时仓库名称和相应的管理员名称也会随之被删除。

你能看到，即便数据表符合 3NF 的要求，同样可能存在插入，更新和删除数据的异常情况。

 

**问题解决**

首先我们需要确认造成异常的原因：主属性仓库名对于候选键（管理员，物品名）是部分依赖的关系，

这样就有可能导致上面的异常情况。因此引入BCNF，**它在** **3NF** **的基础上消除了主属性对候选键的部分依**

**赖或者传递依赖关系**。

如果在关系R中，U为主键，A属性是主键的一个属性，若存在A->Y，Y为主属性，则该关系不属于BCNF。

根据 BCNF 的要求，我们需要把仓库管理关系 warehouse_keeper 表拆分成下面这样：

仓库表 ：（仓库名，管理员）

库存表 ：（仓库名，物品名，数量）

这样就不存在主属性对于候选键的部分依赖或传递依赖，上面数据表的设计就符合 BCNF。

再举例：

有一个 学生导师表 ，其中包含字段：学生ID，专业，导师，专业GPA，这其中学生ID和专业是联合主键。

![image-20240618101148034](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191354775.png)

这个表的设计满足三范式，但是这里存在另一个依赖关系，“专业”依赖于“导师”，也就是说每个导师只

做一个专业方面的导师，只要知道了是哪个导师，我们自然就知道是哪个专业的了。

所以这个表的部分主键Major依赖于非主键属性Advisor，那么我们可以进行以下的调整，拆分成2个表：

学生导师表：

![image-20240618101207129](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191354967.png)

![image-20240618101215780](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191354004.png)

# **第四范式**

**举例****1****：**职工表(职工编号，职工孩子姓名，职工选修课程)。

在这个表中，同一个职工可能会有多个职工孩子姓名。同样，同一个职工也可能会有多个职工选修课程，即这里存在着多值事实，不符合第四范式。

如果要符合第四范式，只需要将上表分为两个表，使它们只有一个多值事实，例如： 职工表一 (职工编

号，职工孩子姓名)， 职工表二 (职工编号，职工选修课程)，两个表都只有一个多值事实，所以符合第四范式。

**举例****2****：**

比如我们建立课程、教师、教材的模型。我们规定，每门课程有对应的一组教师，每门课程也有对应的

一组教材，一门课程使用的教材和教师没有关系。我们建立的关系表如下：

课程ID，教师ID，教材ID；这三列作为联合主键。为了表述方便，我们用Name代替ID，这样更容易看懂：

![image-20240618101249179](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191354918.png)

这个表除了主键，就没有其他字段了，所以肯定满足BC范式，但是却存在 多值依赖 导致的异常。

假如我们下学期想采用一本新的英版高数教材，但是还没确定具体哪个老师来教，那么我们就无法在这

个表中维护Course高数和Book英版高数教材的的关系。

解决办法是我们把这个多值依赖的表拆解成2个表，分别建立关系。这是我们拆分后的表：

![image-20240618101301558](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191354107.png)

以及

![image-20240618101315322](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406191354466.png)

# **第五范式、域键范式**

除了第四范式外，我们还有更高级的第五范式（又称完美范式）和域键范式（DKNF）。

在满足第四范式（4NF）的基础上，消除不是由候选键所蕴含的连接依赖。**如果关系模式****R****中的每一个连**

**接依赖均由****R****的候选键所隐含**，则称此关系模式符合第五范式。

函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上是连接依赖的一种特殊情况。但连接依赖不

像函数依赖和多值依赖可以由 语义直接导出 ，而是在 关系连接运算 时才反映出来。存在连接依赖的关系

模式仍可能遇到数据冗余及插入、修改、删除异常等问题。

第五范式处理的是 无损连接问题 ，这个范式基本 没有实际意义 ，因为无损连接很少出现，而且难以察

觉。而域键范式试图定义一个 终极范式 ，该范式考虑所有的依赖和约束类型，但是实用价值也是最小

的，只存在理论研究中。

# **ER模型**

