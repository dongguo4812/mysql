# 数据库服务器的优化步骤

当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。 

整个流程划分成了 观察（Show status） 和 行动（Action） 两个部分。字母 S 的部分代表观察（会使 用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。

![image-20240605085904565](https://gitee.com/dongguo4812_admin/image/raw/master/image/202406110901487.png)

我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的 SQL 都有哪些，查看具体的SQL执行计划,甚至是SQL执行中的每一步的成本代价,这样才能定位问题所在,找到了问题,再采取相应的行动。

详细解释一下这张图：首先在 S1 部分，我们需要观察服务器的状态是否存在周期性的波动。如果存在周期性波动，有可能是周期性节点的原因,比如双十一、促销活动等。这样的话,我们可以通过A1这一步骤解决,也就是加缓存,或者更改缓存失效策略。

如果缓存策略没有解决,或者不是周期性波动的原因,我们就需要进一步分析查询延迟和卡顿的原因。接下来进入S2 这一步，我们需要开启慢查询。慢查询可以帮我们定位执行慢的 SQL 语句。我们可以通过设置long_query_time参数定义“慢”的阈值，如果 sQL 执行时间超过了 long_query_time，则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。

在S3这一步骤中,我们就知道了执行慢的SQL,这样就可以针对性地用EXPLAIN查看对应SQL语句的执行计划,或者使用show profile查看SQL中每一个步骤的时间成本。这样我们就可以了解sQL查询慢是因为执行时间长，还是等待时间长。

如果是 SQL 等待时间长，我们进入 A2 步骤。在这一步骤中，我们可以 调优服务器的参数，比如适当增加数据库缓冲池等。如果是SQL执行时间长,就进入A3步骤,这一步中我们需要考虑是索引设计的问题?还是查询关联的数据表过多?还是因为数据表的字段设计问题导致了这一现象。然后在这些维度上进行对应的调整。

如果A2和A3都不能解决问题,我们需要考虑数据库自身的SQL查询性能是否已经达到了瓶颈,如果确认没有达到性能瓶颈,就需要重新检查,重复以上的步骤。如果已经达到了性能瓶颈,进入A4阶段,需要考虑增加服务器,采用读写分离的架构,或者考虑对数据库进行分库分表,比如垂直分库、垂直分表和水平分表等。

以上就是数据库调优的流程思路。如果我们发现执行SQL时存在不规则延迟或卡顿的时候,就可以采用分析工具帮我们定位有问题的 SQL，这三种分析工具你可以理解是 SQL 调优的三个步骤：慢查询、EXPLAIN 和SHOWPROFILING。

# **查看系统性能参数**

在MySQL中，可以使用 SHOW STATUS 语句查询一些MySQL数据库服务器的 性能参数 、 执行频率 。

SHOW STATUS语句语法如下：

```sql
SHOW [GLOBAL|SESSION] STATUS LIKE '参数';
```

一些常用的性能参数如下：

 • Connections：连接MySQL服务器的次数。

 • Uptime：MySQL服务器的上线时间。 

• Slow_queries：慢查询的次数。 

• Innodb_rows_read：Select查询返回的行数

•Innodb_rows_inserted：执行INSERT操作插入的行数

• Innodb_rows_updated：执行UPDATE操作更新的行数

• Innodb_rows_deleted：执行DELETE操作删除的行数 

• Com_select：查询操作的次数。 

•Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。 

• Com_update：更新操作的次数。 

• Com_delete：删除操作的次数。

```sql
mysql> show status like 'connections';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Connections   | 8     |
+---------------+-------+
1 row in set (0.00 sec)
```

# 统计SQL的查询成本：last_query_cost

一条SQL 查询语句在执行前需要确定查询执行计划,如果存在多种执行计划的话,MySQL 会计算每个执行计划所需要的成本,从中选择成本最小的一个作为最终执行的执行计划。

如果我们想要查看某条 SQL 语句的查询成本，可以在执行完这条 SQL 语句之后，通过查看当前会话中的last_query_cost 变量值来得到当前查询的成本。它通常也是我们 评价一个查询的执行效率 的一个常用指标。这个查询成本对应的是 SQL 语句所需要读取的页的数量。

我们依然使用 student_info 表为例：

```sql
CREATE TABLE `student_info` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`student_id` INT NOT NULL ,
`name` VARCHAR(20) DEFAULT NULL,
`course_id` INT NOT NULL ,
`class_id` INT(11) DEFAULT NULL,
`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

如果我们想要查询 id=900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：

```sql
mysql> SELECT student_id, class_id, NAME, create_time FROM student_info
    -> WHERE id = 900001;
+------------+----------+--------+---------------------+
| student_id | class_id | NAME   | create_time         |
+------------+----------+--------+---------------------+
|      28091 |    10182 | ZzAeWt | 2024-06-07 10:07:13 |
+------------+----------+--------+---------------------+
1 row in set (0.01 sec)
```

然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：

```sql
mysql> SHOW STATUS LIKE 'last_query_cost';
+-----------------+----------+
| Variable_name   | Value    |
+-----------------+----------+
| Last_query_cost | 1.000000 |
+-----------------+----------+
1 row in set (0.02 sec)
```

如果我们想要查询 id 在 900001 到 9000100 之间的学生记录呢？

```sql
mysql> SELECT student_id, class_id, NAME, create_time FROM student_info WHERE id BETWEEN 900001 AND 900100;
+------------+----------+--------+---------------------+
| student_id | class_id | NAME   | create_time         |
+------------+----------+--------+---------------------+
|      28091 |    10182 | ZzAeWt | 2024-06-07 10:07:13 |
|     102843 |    10026 | jslawg | 2024-06-07 10:07:13 |
|     152707 |    10073 | LrBHIq | 2024-06-07 10:07:13 |
|     158298 |    10025 | DAOwOE | 2024-06-07 10:07:13 |
|      84537 |    10049 | tHduOI | 2024-06-07 10:07:13 |
|      20432 |    10050 | NxaJuX | 2024-06-07 10:07:13 |
|     148694 |    10176 | elRAbF | 2024-06-07 10:07:13 |
|     116343 |    10176 | oJqIuY | 2024-06-07 10:07:13 |
|     184382 |    10075 | yJJBHF | 2024-06-07 10:07:13 |
|      18709 |    10136 | wTgXtb | 2024-06-07 10:07:13 |
|     189581 |    10200 | MSfUkr | 2024-06-07 10:07:13 |
|     157255 |    10035 | uJYXTz | 2024-06-07 10:07:13 |
|     110328 |    10119 | YjcHeB | 2024-06-07 10:07:13 |
|      24542 |    10049 | TbCJyB | 2024-06-07 10:07:13 |
|     151935 |    10050 | cZMPOy | 2024-06-07 10:07:13 |
|     167556 |    10112 | AaABga | 2024-06-07 10:07:13 |
|       5500 |    10084 | TqXPgn | 2024-06-07 10:07:13 |
|      78630 |    10120 | iHJBFw | 2024-06-07 10:07:13 |
|      69556 |    10097 | otbces | 2024-06-07 10:07:13 |
|      82536 |    10075 | WxxUfR | 2024-06-07 10:07:13 |
|      60975 |    10155 | kgYyyV | 2024-06-07 10:07:13 |
|      82208 |    10193 | iEwvNB | 2024-06-07 10:07:13 |
|       4442 |    10043 | xlKSly | 2024-06-07 10:07:13 |
|      13679 |    10051 | DJHlhb | 2024-06-07 10:07:13 |
|      12215 |    10133 | quaVAQ | 2024-06-07 10:07:13 |
|     139550 |    10053 | KtQXoD | 2024-06-07 10:07:13 |
|     111694 |    10016 | CcFWOf | 2024-06-07 10:07:13 |
|     133106 |    10130 | tVxAio | 2024-06-07 10:07:13 |
|      36085 |    10159 | BeTdOH | 2024-06-07 10:07:13 |
|      16709 |    10111 | NAoVJJ | 2024-06-07 10:07:13 |
|      27621 |    10172 | gjBfWr | 2024-06-07 10:07:13 |
|      48800 |    10074 | fOFHvg | 2024-06-07 10:07:13 |
|     120120 |    10157 | IzwLrB | 2024-06-07 10:07:13 |
|      43056 |    10127 | jnLTly | 2024-06-07 10:07:13 |
|      54954 |    10169 | SvArgH | 2024-06-07 10:07:13 |
|     159566 |    10052 | kFuiIP | 2024-06-07 10:07:13 |
|     172945 |    10160 | WcwaOU | 2024-06-07 10:07:13 |
|     102733 |    10151 | qafAnL | 2024-06-07 10:07:13 |
|     171001 |    10016 | bFVMXC | 2024-06-07 10:07:13 |
|     100796 |    10168 | azyROs | 2024-06-07 10:07:13 |
|     117852 |    10084 | JJrFdC | 2024-06-07 10:07:13 |
|      45407 |    10146 | XeFLOM | 2024-06-07 10:07:13 |
|      88068 |    10098 | Lrxoam | 2024-06-07 10:07:13 |
|      79523 |    10192 | ftBChe | 2024-06-07 10:07:13 |
|     144969 |    10103 | elURwK | 2024-06-07 10:07:13 |
|      94599 |    10006 | nUHDWX | 2024-06-07 10:07:13 |
|       4663 |    10198 | iKchFE | 2024-06-07 10:07:13 |
|     104184 |    10154 | pXRqcr | 2024-06-07 10:07:13 |
|      19602 |    10104 | WrUyIV | 2024-06-07 10:07:13 |
|     101374 |    10053 | MjJUww | 2024-06-07 10:07:13 |
|     123510 |    10008 | XXSwFL | 2024-06-07 10:07:13 |
|      47465 |    10189 | sdpoAL | 2024-06-07 10:07:13 |
|     142083 |    10037 | ZSpXSt | 2024-06-07 10:07:13 |
|      94323 |    10144 | kEsYOZ | 2024-06-07 10:07:13 |
|      39696 |    10045 | qZbhIT | 2024-06-07 10:07:13 |
|      89689 |    10065 | nZjVcx | 2024-06-07 10:07:13 |
|     133569 |    10039 | MMvUmA | 2024-06-07 10:07:13 |
|     155357 |    10085 | FJFajV | 2024-06-07 10:07:13 |
|     195233 |    10036 | rLJZdq | 2024-06-07 10:07:13 |
|     118121 |    10035 | wtDNei | 2024-06-07 10:07:13 |
|      49103 |    10033 | LUqUAT | 2024-06-07 10:07:13 |
|     135017 |    10083 | gFJqMN | 2024-06-07 10:07:13 |
|      90882 |    10129 | rrInte | 2024-06-07 10:07:13 |
|      59359 |    10048 | NWuhDs | 2024-06-07 10:07:13 |
|      84412 |    10066 | grqCSD | 2024-06-07 10:07:13 |
|      72484 |    10173 | lcCDlt | 2024-06-07 10:07:13 |
|     154630 |    10020 | CxFKJd | 2024-06-07 10:07:13 |
|     164901 |    10006 | bHiSOp | 2024-06-07 10:07:13 |
|       8914 |    10026 | QYtXHr | 2024-06-07 10:07:13 |
|     195283 |    10172 | pEarJg | 2024-06-07 10:07:13 |
|      88798 |    10067 | lNiAfZ | 2024-06-07 10:07:13 |
|     154422 |    10025 | zfcYKC | 2024-06-07 10:07:13 |
|     162040 |    10155 | LkTKUu | 2024-06-07 10:07:13 |
|     135609 |    10063 | whwJgE | 2024-06-07 10:07:13 |
|     161042 |    10021 | KgyaEX | 2024-06-07 10:07:13 |
|     120312 |    10023 | IytwcZ | 2024-06-07 10:07:13 |
|      99920 |    10195 | DtjNnc | 2024-06-07 10:07:13 |
|     124852 |    10042 | zDvqua | 2024-06-07 10:07:13 |
|       1207 |    10018 | NMxbPT | 2024-06-07 10:07:13 |
|      56259 |    10094 | ZhLkSH | 2024-06-07 10:07:13 |
|      63865 |    10048 | TurCJO | 2024-06-07 10:07:13 |
|      23447 |    10188 | OBrcon | 2024-06-07 10:07:13 |
|     163421 |    10086 | PCtjQB | 2024-06-07 10:07:13 |
|     192162 |    10106 | lktmcC | 2024-06-07 10:07:13 |
|      50515 |    10084 | anoHuc | 2024-06-07 10:07:13 |
|     112268 |    10030 | sfyZCQ | 2024-06-07 10:07:13 |
|      32740 |    10138 | MmWZjT | 2024-06-07 10:07:13 |
|     109076 |    10124 | TLbVAR | 2024-06-07 10:07:13 |
|      18799 |    10165 | aMKnji | 2024-06-07 10:07:13 |
|     176132 |    10144 | mEjgfg | 2024-06-07 10:07:13 |
|      68587 |    10053 | VDcCHC | 2024-06-07 10:07:13 |
|        933 |    10053 | leNDBX | 2024-06-07 10:07:13 |
|      90015 |    10199 | obrDSE | 2024-06-07 10:07:13 |
|      26839 |    10008 | BoQmLV | 2024-06-07 10:07:13 |
|      93963 |    10069 | qhMrwi | 2024-06-07 10:07:13 |
|     101912 |    10200 | ClyKer | 2024-06-07 10:07:13 |
|     162995 |    10000 | dTkshK | 2024-06-07 10:07:13 |
|     115165 |    10028 | xAkAVe | 2024-06-07 10:07:13 |
|     156719 |    10188 | fiBhgi | 2024-06-07 10:07:13 |
|     176121 |    10172 | RzaBHI | 2024-06-07 10:07:13 |
+------------+----------+--------+---------------------+
100 rows in set (0.00 sec)
```

然后再看下查询优化器的成本，这时我们大概需要进行 20 个页的查询。

```sql
mysql> SHOW STATUS LIKE 'last_query_cost';
+-----------------+-----------+
| Variable_name   | Value     |
+-----------------+-----------+
| Last_query_cost | 20.290751 |
+-----------------+-----------+
1 row in set (0.00 sec)
```

你能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间

基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然 页

数量（last_query_cost）增加了不少 ，但是通过缓冲池的机制，并 没有增加多少查询时间 。

 

# 定位执行慢的 SQL：慢查询日志

MysQL的慢查询日志,用来记录在MySQL中响应时间超过阀值的语句,具体指运行时间超过long-query-time值的SQL,则会被记录到慢查询日志中。long_query_time的默认值为10,意思是运行10秒以上(不含10秒)的语句，认为是超出了我们的最大忍耐时间值。

它的主要作用是,帮助我们发现那些执行时间特别长的SQL查询,并且有针对性地进行优化,从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条sql执行超过5秒钟,我们就算慢SQL,希望能收集超过5秒的sql,结合explain进行全面分析。

默认情况下,MySQL数据库没有开启慢查询日志,需要我们手动来设置这个参数。如果不是调优需要的话,一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。

## 开启慢查询日志参数

**1.** **开启****slow_query_log**

在使用前，我们需要先看下慢查询是否已经开启，使用下面这条命令即可：

```sql
mysql> show variables like '%slow_query_log';
+----------------+-------+
| Variable_name  | Value |
+----------------+-------+
| slow_query_log | OFF   |
+----------------+-------+
1 row in set (0.00 sec)
```

我们能看到slow_query_log=OFF,我们可以把慢查询日志打开,注意设置变量值的时候需要使用global,否则会报错：

```sql
mysql> set global slow_query_log='ON';
Query OK, 0 rows affected (0.02 sec)
#然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：
mysql> show variables like '%slow_query_log%';
+---------------------+---------------------------------+
| Variable_name       | Value                           |
+---------------------+---------------------------------+
| slow_query_log      | ON                              |
| slow_query_log_file | /var/lib/mysql/dongguo-slow.log |
+---------------------+---------------------------------+
2 rows in set (0.00 sec)
```

你能看到这时慢查询分析已经开启，同时文件保存在 /var/lib/mysql/dongguo-slow.log 文件中

**2.** **修改****long_query_time****阈值**

接下来我们来看下慢查询的时间阈值设置，使用如下命令：

```sql
mysql> show variables like '%long_query_time%';
+-----------------+-----------+
| Variable_name   | Value     |
+-----------------+-----------+
| long_query_time | 10.000000 |
+-----------------+-----------+
1 row in set (0.00 sec)
```

这里如果我们想把时间缩短，比如设置为 1 秒，可以这样设置：

```sql
#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并执行下述语句
mysql> show variables like '%long_query_time%';
+-----------------+-----------+
| Variable_name   | Value     |
+-----------------+-----------+
| long_query_time | 10.000000 |
+-----------------+-----------+
1 row in set (0.00 sec)

mysql> set global long_query_time = 1;
Query OK, 0 rows affected (0.00 sec)

mysql> show global variables like '%long_query_time%';
+-----------------+----------+
| Variable_name   | Value    |
+-----------------+----------+
| long_query_time | 1.000000 |
+-----------------+----------+
1 row in set (0.00 sec)

mysql> set long_query_time=1;
Query OK, 0 rows affected (0.00 sec)

mysql>  show variables like '%long_query_time%';
+-----------------+----------+
| Variable_name   | Value    |
+-----------------+----------+
| long_query_time | 1.000000 |
+-----------------+----------+
1 row in set (0.00 sec)
```

## **查看慢查询数目**

查询当前系统中有多少条慢查询记录

```sql
mysql> SHOW GLOBAL STATUS LIKE '%Slow_queries%';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Slow_queries  | 1     |
+---------------+-------+
1 row in set (0.00 sec)
```

## **案例演示**

**步骤****1.** **建表**

```sql
CREATE TABLE `student` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`stuno` INT NOT NULL ,
`name` VARCHAR(20) DEFAULT NULL,
`age` INT(3) DEFAULT NULL,
`classId` INT(11) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

**步骤**2：创建函数

随机产生字符串：

```sql
DELIMITER //
CREATE FUNCTION rand_string(n INT)
	RETURNS VARCHAR(255) #该函数会返回一个字符串
BEGIN
	DECLARE chars_str VARCHAR(100) DEFAULT
'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
	DECLARE return_str VARCHAR(255) DEFAULT '';
	DECLARE i INT DEFAULT 0;
	WHILE i < n DO
		SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
		SET i = i + 1;
	END WHILE;
	RETURN return_str;
END //
DELIMITER ;
#测试
SELECT rand_string(10);
```

产生随机数值：

```sql
DELIMITER //
CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)
BEGIN
DECLARE i INT DEFAULT 0;
SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;
RETURN i;
END //
DELIMITER ;
#测试：
SELECT rand_num(10,100);
```

**步骤3：创建存储过程**

```sql
DELIMITER //
CREATE PROCEDURE insert_stu1( START INT , max_num INT )
BEGIN
DECLARE i INT DEFAULT 0;
SET autocommit = 0; #设置手动提交事务
REPEAT #循环
	SET i = i + 1; #赋值
	INSERT INTO student (stuno, NAME ,age ,classId ) VALUES
((START+i),rand_string(6),rand_num(10,100),rand_num(10,1000));
	UNTIL i = max_num
	END REPEAT;
	COMMIT; #提交事务
END //
DELIMITER ;
```

**步骤4：调用存储过程**

```sql
CALL insert_stu1(100001,4000000);
```

## **测试及分析**

### **1.** **测试**

```sql
mysql> SELECT * FROM student WHERE stuno = 3455655;
+---------+---------+--------+------+---------+
| id      | stuno   | name   | age  | classId |
+---------+---------+--------+------+---------+
| 3355654 | 3455655 | fxXuhz |   16 |     859 |
+---------+---------+--------+------+---------+
1 row in set (1.21 sec)

mysql> SELECT * FROM student WHERE name = 'oQmLUr';
+---------+---------+--------+------+---------+
| id      | stuno   | name   | age  | classId |
+---------+---------+--------+------+---------+
|  616615 |  716616 | oqMLuR |   10 |     529 |
| 1013531 | 1113532 | Oqmlur |   51 |     306 |
| 1464808 | 1564809 | oqMLuR |   10 |     489 |
| 1515167 | 1615168 | Oqmlur |   51 |     313 |
| 1657394 | 1757395 | OQMlUR |   54 |     933 |
| 1824718 | 1924719 | Oqmlur |   53 |     373 |
| 2573090 | 2673091 | oQmLUr |   99 |     905 |
| 2877146 | 2977147 | Oqmlur |   52 |     361 |
| 3716132 | 3816133 | oQmLUr |  100 |     956 |
+---------+---------+--------+------+---------+
9 rows in set (1.06 sec)
```

目前查询效率是比较低的，下面的小节我们分析一下原因。

## **慢查询日志分析工具：**mysqldumpslow

在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具

mysqldumpslow 。

查看mysqldumpslow的帮助信息

```shell
[root@dongguo ~]# mysqldumpslow --help
Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]

Parse and summarize the MySQL slow query log. Options are

  --verbose    verbose
  --debug      debug
  --help       write this text to standard output

  -v           verbose
  -d           debug
  -s ORDER     what to sort by (al, at, ar, c, l, r, t), 'at' is default
                al: average lock time
                ar: average rows sent
                at: average query time
                 c: count
                 l: lock time
                 r: rows sent
                 t: query time  
  -r           reverse the sort order (largest last instead of first)
  -t NUM       just show the top n queries
  -a           don't abstract all numbers to N and strings to 'S'
  -n NUM       abstract numbers with at least n digits within names
  -g PATTERN   grep: only consider stmts that include this string
  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),
               default is '*', i.e. match all
  -i NAME      name of server instance (if using mysql.server startup script)
  -l           don't subtract lock time from total time

[root@dongguo ~]# 
```

mysqldumpslow 命令的具体参数如下：
-a: 不将数字抽象成N，字符串抽象成S
-s: 是表示按照何种方式排序：
	c: 访问次数
	l: 锁定时间
	r: 返回记录
	t: 查询时间
	al:平均锁定时间
	ar:平均返回记录数
	at:平均查询时间 （默认方式）
	ac:平均查询次数
-t: 即为返回前面多少条的数据；
-g: 后边搭配一个正则匹配模式，大小写不敏感的；

之前我们看到慢查询日志文件在/var/lib/mysql/dongguo-slow.log

举例：我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：

```shell
[root@dongguo ~]# mysqldumpslow -a -s t -t 5 /var/lib/mysql/dongguo-slow.log

Reading mysql slow query log from /var/lib/mysql/dongguo-slow.log
Count: 1  Time=256.28s (256s)  Lock=0.00s (0s)  Rows=0.0 (0), root[root]@localhost
  CALL insert_stu1(100001,4000000)

Count: 1  Time=1.24s (1s)  Lock=0.00s (0s)  Rows=1.0 (1), root[root]@localhost
  SELECT * FROM student WHERE stuno = 3455655

Count: 1  Time=1.07s (1s)  Lock=0.00s (0s)  Rows=9.0 (9), root[root]@localhost
  SELECT * FROM student WHERE name = 'oQmLUr'

Died at /usr/bin/mysqldumpslow line 162, <> chunk 3.
```

可以看到一共有三条慢查询

**工作常用命令参考：**

```shell
#得到返回记录集最多的10个SQL
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log
#得到访问次数最多的10个SQL
mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log
#得到按照时间排序的前10条里面含有左连接的查询语句
mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/atguigu-slow.log
#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more
```

## **关闭慢查询日志**

MySQL服务器停止慢查询日志功能有两种方法：

**方式****1：永久性方式**

```shell
[mysqld]
slow_query_log=OFF
```

或者，把slow_query_log一项注释掉 或 删除

```shell
[mysqld]
#slow_query_log =OFF
```

重启MySQL服务，执行如下语句查询慢日志功能。

```sql
SHOW VARIABLES LIKE '%slow%'; #查询慢查询日志所在目录
SHOW VARIABLES LIKE '%long_query_time%'; #查询超时时长
```

**方式****2：临时性方式**

使用SET语句来设置。

 （1）停止MySQL慢查询日志功能，具体SQL语句如下。

```sql
SET GLOBAL slow_query_log=off;
```

（2）重启MySQL服务，使用SHOW语句查询慢查询日志功能信息，具体SQL语句如下

```sql
SHOW VARIABLES LIKE '%slow%';
#以及
SHOW VARIABLES LIKE '%long_query_time%';
```

 

## **删除慢查询日志**

1.手动删除慢查询日志文件 即可

2.使用命令mysqladmin flush-logs来重新生成查询日志文件,具体命令如下,执行完毕会在数据目录下重新生成慢查询日志文件。

```sql
mysqladmin -uroot -p flush-logs slow
```

提示:慢查询日志都是使用mysqladmin flush-logs命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。

# **查看** **SQL** 执行成本：SHOW PROFILE

Show Profile是MySQL提供的可以用来分析当前会话中SQL都做了什么、执行的资源消耗情况的工具,可用于sql调优的测量。 默认情况下处于关闭状态，并保存最近15次的运行结果。

```sql
mysql> show variables like 'profiling';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| profiling     | OFF   |
+---------------+-------+
1 row in set (0.01 sec)
```

通过设置 profiling='ON’ 来开启 show profile：

```sql
mysql> set profiling = 'ON';
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql> show variables like 'profiling';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| profiling     | ON    |
+---------------+-------+
1 row in set (0.00 sec)
```

然后执行相关的查询语句。接着看下当前会话都有哪些 profiles，使用下面这条命令：

```sql
show profiles;
```

。如果我们想要查看最近一次查询的开销，可以使用：

```sql
show profile;
```

# 分析查询语句：EXPLAIN

## **概述**

定位了查询慢的SQL之后,我们就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句。 DESCRIBE语句的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。

MySQL中有专门负责优化SELECT语句的优化器模块,主要功能:通过计算分析系统中收集到的统计信息,为客户端请求的Query提供它认为最优的执行计划(他认为最优的数据检索方式,但不见得是DBA认为是最优的,这部分最耗费时间）。

这个执行计划展示了接下来具体执行查询的方式,比如多表连接的顺序是什么,对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划,大家看懂EXPLAIN 语句的各个输出项，可以有针对性的提升我们查询语句的性能。

**官网介绍**

**https://dev.mysql.com/doc/refman/5.7/en/explain-output.html**

**https://dev.mysql.com/doc/refman/8.0/en/explain-output.html**

**版本情况**

MySQL 5.6.3以前只能 EXPLAIN SELECT ；MYSQL 5.6.3以后就可以 EXPLAIN SELECT，UPDATE，

DELETE

在5.7以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示

filtered 需要使用 explain extended 命令。在5.7版本后，默认explain直接显示partitions和

filtered中的信息。

## **基本语法**

EXPLAIN 或 DESCRIBE语句的语法形式如下：

```sql
EXPLAIN SELECT select_options
或者
DESCRIBE SELECT select_options
```

如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN ，就像这样：

```sql
mysql>  EXPLAIN SELECT 1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
1 row in set, 1 warning (0.00 sec)
```

输出的上述信息就是所谓的执行计划。在这个执行计划的辅助下,我们需要知道应该怎样改进自己的查询语句以使查询执行起来更高效。其实除了以SELECT开头的查询语句,其余的DELETE、INSERT、REPLACE以及UPDATE语句等都可以加上EXPLAIN,用来查看这些语句的执行计划,只是平时我们对SELECT语句更感兴趣。

注意：执行EXPLAIN时并没有真正的执行该后面的语句，因此可以安全的查看执行计划。

| **列名**      | **描述**                                                |
| ------------- | ------------------------------------------------------- |
| id            | 在一个大的查询语句中每个SELECT关键字都对应一个 唯一的id |
| select_type   | SELECT关键字对应的那个查询的类型                        |
| table         | 表名                                                    |
| partitions    | 匹配的分区信息                                          |
| type          | 针对单表的访问方法                                      |
| possible_keys | 可能用到的索引                                          |
| key           | 实际上使用的索引                                        |
| key_len       | 实际使用到的索引长度                                    |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息  |
| rows          | 预估的需要读取的记录条数                                |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比            |
| Extra         | 一些额外的信息                                          |



 

## **数据准备**

 

### **建表**

```sql
CREATE TABLE s1 (
id INT AUTO_INCREMENT,
key1 VARCHAR(100),
key2 INT,
key3 VARCHAR(100),
key_part1 VARCHAR(100),
key_part2 VARCHAR(100),
key_part3 VARCHAR(100),
common_field VARCHAR(100),
PRIMARY KEY (id),
INDEX idx_key1 (key1),
UNIQUE INDEX idx_key2 (key2),
INDEX idx_key3 (key3),
INDEX idx_key_part(key_part1, key_part2, key_part3)
) ENGINE=INNODB CHARSET=utf8;
```



```sql
CREATE TABLE s2 (
id INT AUTO_INCREMENT,
key1 VARCHAR(100),
key2 INT,
key3 VARCHAR(100),
key_part1 VARCHAR(100),
key_part2 VARCHAR(100),
key_part3 VARCHAR(100),
common_field VARCHAR(100),
PRIMARY KEY (id),
INDEX idx_key1 (key1),
UNIQUE INDEX idx_key2 (key2),
INDEX idx_key3 (key3),
INDEX idx_key_part(key_part1, key_part2, key_part3)
) ENGINE=INNODB CHARSET=utf8;
```

### **创建函数**

```sql
DELIMITER //
CREATE FUNCTION rand_string1(n INT)
	RETURNS VARCHAR(255) #该函数会返回一个字符串
BEGIN
	DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
	DECLARE return_str VARCHAR(255) DEFAULT '';
	DECLARE i INT DEFAULT 0;
	WHILE i < n DO
		SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
		SET i = i + 1;
	END WHILE;
	RETURN return_str;
END //
DELIMITER ;
```

### **创建存储过程**

创建往s1表中插入数据的存储过程：

```sql
DELIMITER //
CREATE PROCEDURE insert_s1 (IN min_num INT (10),IN max_num INT (10))
BEGIN
    DECLARE i INT DEFAULT 0;
    SET autocommit = 0;
    REPEAT
    SET i = i + 1;
    INSERT INTO s1 VALUES(
    (min_num + i),
    rand_string1(6),
    (min_num + 30 * i + 5),
    rand_string1(6),
    rand_string1(10),
    rand_string1(5),
    rand_string1(10),
    rand_string1(10));
    UNTIL i = max_num
    END REPEAT;
    COMMIT;
END //
DELIMITER ;
```

创建往s2表中插入数据的存储过程：

```sql
DELIMITER //
CREATE PROCEDURE insert_s2 (IN min_num INT (10),IN max_num INT (10))
BEGIN
    DECLARE i INT DEFAULT 0;
    SET autocommit = 0;
    REPEAT
    SET i = i + 1;
    INSERT INTO s2 VALUES(
        (min_num + i),
        rand_string1(6),
        (min_num + 30 * i + 5),
        rand_string1(6),
        rand_string1(10),
        rand_string1(5),
        rand_string1(10),
        rand_string1(10));
    UNTIL i = max_num
    END REPEAT;
    COMMIT;
END //
DELIMITER ;
```

 **调用存储过程**

```sql
#s1表数据的添加：加入1万条记录：
CALL insert_s1(10001,10000);
#s2表数据的添加：加入1万条记录：
CALL insert_s2(10001,10000);
```

 

## EXPLAIN各列作用

### **1. table**

不论我们的查询语句有多复杂，里边儿 包含了多少个表 ，到最后也是需要对每个表进行 单表访问 的，所

以MySQL规定**EXPLAIN**语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。

查询的每一行记录都对应一个单表

```sql
mysql> EXPLAIN select * from s1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9666 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

s1:驱动表，s2:被驱动表

```sql
mysql> EXPLAIN select * from s1 inner join s2;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                         |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9666 |   100.00 | NULL                          |
|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9702 |   100.00 | Using join buffer (hash join) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+
2 rows in set, 1 warning (0.00 sec)
```



### **2. id**

```sql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

id如果相同，可以认为是一组，从上往下顺序执行
在所有组中，id值越大，优先级越高，越先执行
关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好

### **3. select_type**

| **名称**             | 描述                                                         |
| -------------------- | ------------------------------------------------------------ |
| SIMPLE               | Simple SELECT (not using UNION or subqueries)                |
| PRIMARY              | Outermost SELECT                                             |
| UNION                | Second or later SELECT statement in a UNION                  |
| UNION RESULT         | Result of a UNION                                            |
| SUBQUERY             | First SELECT in subquery                                     |
| DEPENDENT SUBQUERY   | First SELECT in subquery, dependent on outer query           |
| DEPENDENT UNION      | Second or later SELECT statement in a UNION, dependent on outer query |
| DERIVED              | Derived table                                                |
| MATERIALIZED         | Materialized subquery                                        |
| UNCACHEABLE SUBQUERY | A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query |
| UNCACHEABLE UNION    | The second or later select in a UNION that belongs to an uncacheable subquery(see UNCACHEABLE SUBQUERY) |

具体分析如下：

```sql
mysql> EXPLAIN SELECT * FROM s1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9666 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

PRIMARY

```
mysql> EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9666 |   100.00 | NULL            |
|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9702 |   100.00 | NULL            |
|  3 | UNION RESULT | <union1,2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |
+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
3 rows in set, 1 warning (0.00 sec)
```

### 4.**partitions (可略)**



### **5. type**

完整的访问方法如下： system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ，

index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL 。

### **6. possible_keys和key**

### **7. key_len**

### **8. ref**

### **9. rows**

### **10. filtered**

### **11. Extra**

# **EXPLAIN的进一步使用**

## **EXPLAIN**四种输出格式

EXPLAIN可以输出四种格式： 传统格式 ， JSON格式 ， TREE格式 以及 可视化输出 。用户可以根据需要选择适用于自己的格式。

**1.** **传统格式**

传统格式简单明了，输出是一个表格形式，概要说明查询计划。

```sql
mysql> EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
+----+-------------+-------+------------+------+---------------+----------+---------+-----------------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref             | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+----------+---------+-----------------+------+----------+-------------+
|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL            | 9702 |    90.00 | Using where |
|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | dbtest1.s2.key1 |    1 |   100.00 | Using index |
+----+-------------+-------+------------+------+---------------+----------+---------+-----------------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
```

**2. JSON格式**

JSON格式：在EXPLAIN单词和真正的查询语句中间加上 FORMAT=JSON 

```sql
mysql> EXPLAIN FORMAT=JSON SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| EXPLAIN                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| {
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "4099.56"
    },
    "nested_loop": [
      {
        "table": {
          "table_name": "s2",
          "access_type": "ALL",
          "possible_keys": [
            "idx_key1"
          ],
          "rows_examined_per_scan": 9702,
          "rows_produced_per_join": 8731,
          "filtered": "90.00",
          "cost_info": {
            "read_cost": "121.27",
            "eval_cost": "873.18",
            "prefix_cost": "994.45",
            "data_read_per_join": "15M"
          },
          "used_columns": [
            "key1",
            "common_field"
          ],
          "attached_condition": "((`dbtest1`.`s2`.`common_field` is not null) and (`dbtest1`.`s2`.`key1` is not null))"
        }
      },
      {
        "table": {
          "table_name": "s1",
          "access_type": "ref",
          "possible_keys": [
            "idx_key1"
          ],
          "key": "idx_key1",
          "used_key_parts": [
            "key1"
          ],
          "key_length": "303",
          "ref": [
            "dbtest1.s2.key1"
          ],
          "rows_examined_per_scan": 1,
          "rows_produced_per_join": 9180,
          "filtered": "100.00",
          "using_index": true,
          "cost_info": {
            "read_cost": "2187.10",
            "eval_cost": "918.01",
            "prefix_cost": "4099.56",
            "data_read_per_join": "15M"
          },
          "used_columns": [
            "key1"
          ]
        }
      }
    ]
  }
} |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set, 1 warning (0.00 sec)
```

**3. TREE格式**

TREE格式是8.0.16版本之后引入的新格式，主要根据查询的 各个部分之间的关系 和 各部分的执行顺序 来描述如何查询

```sql
mysql> EXPLAIN FORMAT=tree SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a'\G
*************************** 1. row ***************************
EXPLAIN: -> Nested loop inner join  (cost=1329 rows=967)
    -> Filter: ((s1.common_field = 'a') and (s1.key1 is not null))  (cost=991 rows=967)
        -> Table scan on s1  (cost=991 rows=9666)
    -> Single-row index lookup on s2 using idx_key2 (key2=s1.key1), with index condition: (cast(s1.key1 as double) = cast(s2.key2 as double))  (cost=0.25 rows=1)

1 row in set, 1 warning (0.00 sec)
```

**4.** **可视化输出**

可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。通过点击Workbench的放大镜图标，即可生成可视化的查询计划。

上图按从左到右的连接顺序显示表。红色框表示 全表扫描 ，而绿色框表示使用 索引查找 。对于每个表，

显示使用的索引。还要注意的是，每个表格的框上方是每个表访问所发现的行数的估计值以及访问该表

的成本。

 

## **SHOW WARNINGS的使用**

```sql
mysql> EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
+----+-------------+-------+------------+------+---------------+----------+---------+-----------------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref             | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+----------+---------+-----------------+------+----------+-------------+
|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL            | 9702 |    90.00 | Using where |
|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | dbtest1.s2.key1 |    1 |   100.00 | Using index |
+----+-------------+-------+------------+------+---------------+----------+---------+-----------------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
```

用于显示最近执行的 SQL 语句所产生的警告信息。执行这个命令后，会返回一个包含警告详细信息的结果集。

```sql
mysql> SHOW WARNINGS\G
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `dbtest1`.`s1`.`key1` AS `key1`,`dbtest1`.`s2`.`key1` AS `key1` from `dbtest1`.`s1` join `dbtest1`.`s2` where ((`dbtest1`.`s1`.`key1` = `dbtest1`.`s2`.`key1`) and (`dbtest1`.`s2`.`common_field` is not null))
1 row in set (0.00 sec)
```

# **分析优化器执行计划：trace**

OPTIMIZER_TRACE是MySQL 5.6引入的一项跟踪功能，它可以跟踪优化器做出的各种决策（比如访问表的方法、各种开销计算、各种转换等) ,并将跟踪结果记录到INFORMATION-SCHEMA.OPTIMIZER-TRACE表中。此功能默认关闭。开启trace,并设置格式为JSON,同时设置trace最大能够使用的内存大小,避免解析过程中因为默认内存过小而不能够完整展示。

```sql
mysql> SET optimizer_trace="enabled=on",end_markers_in_json=on;
Query OK, 0 rows affected (0.00 sec)

mysql> set optimizer_trace_max_mem_size=1000000;
Query OK, 0 rows affected (0.00 sec)
```

开启后，可分析如下语句：

SELECT

INSERT

REPLACE

UPDATE

DELETE

EXPLAIN

SET

DECLARE

CASE

IF

RETURN

CALL

测试：执行如下SQL语句

```sql
mysql> select * from student where id < 10;
+----+--------+--------+------+---------+
| id | stuno  | name   | age  | classId |
+----+--------+--------+------+---------+
|  1 | 100002 | ENehwN |   53 |     121 |
|  2 | 100003 | hrotaW |   71 |     547 |
|  3 | 100004 | KSioVM |   99 |     655 |
|  4 | 100005 | qHozDt |   28 |     854 |
|  5 | 100006 | IOSYnv |   33 |      67 |
|  6 | 100007 | BxHTzQ |   61 |     406 |
|  7 | 100008 | prMKps |   94 |     566 |
|  8 | 100009 | avZLFV |   76 |     892 |
|  9 | 100010 | oLMCCg |   94 |     277 |
+----+--------+--------+------+---------+
9 rows in set (0.00 sec)
```

最后， 查询 information_schema.optimizer_trace 就可以知道MySQL是如何执行SQL的 ：

```sql
mysql> select * from information_schema.optimizer_trace\G
*************************** 1. row ***************************
                            QUERY: select * from student where id < 10
                            TRACE: {
  "steps": [
    {
      "join_preparation": {
        "select#": 1,
        "steps": [
          {
            "expanded_query": "/* select#1 */ select `student`.`id` AS `id`,`student`.`stuno` AS `stuno`,`student`.`name` AS `name`,`student`.`age` AS `age`,`student`.`classId` AS `classId` from `student` where (`student`.`id` < 10)"
          }
        ] /* steps */
      } /* join_preparation */
    },
    {
      "join_optimization": {
        "select#": 1,
        "steps": [
          {
            "condition_processing": {
              "condition": "WHERE",
              "original_condition": "(`student`.`id` < 10)",
              "steps": [
                {
                  "transformation": "equality_propagation",
                  "resulting_condition": "(`student`.`id` < 10)"
                },
                {
                  "transformation": "constant_propagation",
                  "resulting_condition": "(`student`.`id` < 10)"
                },
                {
                  "transformation": "trivial_condition_removal",
                  "resulting_condition": "(`student`.`id` < 10)"
                }
              ] /* steps */
            } /* condition_processing */
          },
          {
            "substitute_generated_columns": {
            } /* substitute_generated_columns */
          },
          {
            "table_dependencies": [
              {
                "table": "`student`",
                "row_may_be_null": false,
                "map_bit": 0,
                "depends_on_map_bits": [
                ] /* depends_on_map_bits */
              }
            ] /* table_dependencies */
          },
          {
            "ref_optimizer_key_uses": [
            ] /* ref_optimizer_key_uses */
          },
          {
            "rows_estimation": [
              {
                "table": "`student`",
                "range_analysis": {
                  "table_scan": {
                    "rows": 3990093,
                    "cost": 405260
                  } /* table_scan */,
                  "potential_range_indexes": [
                    {
                      "index": "PRIMARY",
                      "usable": true,
                      "key_parts": [
                        "id"
                      ] /* key_parts */
                    }
                  ] /* potential_range_indexes */,
                  "setup_range_conditions": [
                  ] /* setup_range_conditions */,
                  "group_index_range": {
                    "chosen": false,
                    "cause": "not_group_by_or_distinct"
                  } /* group_index_range */,
                  "skip_scan_range": {
                    "potential_skip_scan_indexes": [
                      {
                        "index": "PRIMARY",
                        "usable": false,
                        "cause": "query_references_nonkey_column"
                      }
                    ] /* potential_skip_scan_indexes */
                  } /* skip_scan_range */,
                  "analyzing_range_alternatives": {
                    "range_scan_alternatives": [
                      {
                        "index": "PRIMARY",
                        "ranges": [
                          "id < 10"
                        ] /* ranges */,
                        "index_dives_for_eq_ranges": true,
                        "rowid_ordered": true,
                        "using_mrr": false,
                        "index_only": false,
                        "in_memory": 0.512889,
                        "rows": 9,
                        "cost": 1.53146,
                        "chosen": true
                      }
                    ] /* range_scan_alternatives */,
                    "analyzing_roworder_intersect": {
                      "usable": false,
                      "cause": "too_few_roworder_scans"
                    } /* analyzing_roworder_intersect */
                  } /* analyzing_range_alternatives */,
                  "chosen_range_access_summary": {
                    "range_access_plan": {
                      "type": "range_scan",
                      "index": "PRIMARY",
                      "rows": 9,
                      "ranges": [
                        "id < 10"
                      ] /* ranges */
                    } /* range_access_plan */,
                    "rows_for_plan": 9,
                    "cost_for_plan": 1.53146,
                    "chosen": true
                  } /* chosen_range_access_summary */
                } /* range_analysis */
              }
            ] /* rows_estimation */
          },
          {
            "considered_execution_plans": [
              {
                "plan_prefix": [
                ] /* plan_prefix */,
                "table": "`student`",
                "best_access_path": {
                  "considered_access_paths": [
                    {
                      "rows_to_scan": 9,
                      "access_type": "range",
                      "range_details": {
                        "used_index": "PRIMARY"
                      } /* range_details */,
                      "resulting_rows": 9,
                      "cost": 2.43146,
                      "chosen": true
                    }
                  ] /* considered_access_paths */
                } /* best_access_path */,
                "condition_filtering_pct": 100,
                "rows_for_plan": 9,
                "cost_for_plan": 2.43146,
                "chosen": true
              }
            ] /* considered_execution_plans */
          },
          {
            "attaching_conditions_to_tables": {
              "original_condition": "(`student`.`id` < 10)",
              "attached_conditions_computation": [
              ] /* attached_conditions_computation */,
              "attached_conditions_summary": [
                {
                  "table": "`student`",
                  "attached": "(`student`.`id` < 10)"
                }
              ] /* attached_conditions_summary */
            } /* attaching_conditions_to_tables */
          },
          {
            "finalizing_table_conditions": [
              {
                "table": "`student`",
                "original_table_condition": "(`student`.`id` < 10)",
                "final_table_condition   ": "(`student`.`id` < 10)"
              }
            ] /* finalizing_table_conditions */
          },
          {
            "refine_plan": [
              {
                "table": "`student`"
              }
            ] /* refine_plan */
          }
        ] /* steps */
      } /* join_optimization */
    },
    {
      "join_execution": {
        "select#": 1,
        "steps": [
        ] /* steps */
      } /* join_execution */
    }
  ] /* steps */
}
MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0
          INSUFFICIENT_PRIVILEGES: 0
1 row in set (0.00 sec)
```

# **MySQL监控分析视图-sys schema**

关于MySQL的性能监控和问题诊断,我们一般都从performance_schema中去获取想要的数据,在MySQL5.7.7版本中新增sys schema,它将performance_schema和information_schema中的数据以更容易理解的方式总结归纳为"视图”,其目的就是为了降低查询performance_schema的复杂度,让DBA能够快速的定位问题。下面看看这些库中都有哪些监控表和视图,掌握了这些,在我们开发和运维的过程中就起到了事半功倍的效果。

### **Sys schema视图摘要**

**1.** **主机相关：**以host_summary开头，主要汇总了IO延迟的信息。

**2. Innodb****相关：**以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。

**3. I/o****相关：**以io开头，汇总了等待I/O、I/O使用量情况。

**4.** **内存使用情况：**以memory开头，从主机、线程、事件等角度展示内存的使用情况

**5.** **连接与会话信息：**processlist和session相关视图，总结了会话相关信息。

**6.** **表相关：**以schema_table开头的视图，展示了表的统计信息。

**7.** **索引信息：**统计了索引的使用情况，包含冗余索引和未使用的索引情况。

**8.** **语句相关：**以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。

**9.** **用户相关：**以user开头的视图，统计了用户使用的文件I/O、执行语句统计信息。

**10.** **等待事件相关信息：**以wait开头，展示等待事件的延迟情况。

 

### **Sys schema视图使用场景**

**索引情况**

```sql
#1. 查询冗余索引
select * from sys.schema_redundant_indexes;
#2. 查询未使用过的索引
select * from sys.schema_unused_indexes;
#3. 查询索引的使用情况
select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted
from sys.schema_index_statistics where table_schema='dbname' ;
```

**表相关**

```sql
# 1. 查询表的访问量
select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from
sys.schema_table_statistics group by table_schema,table_name order by io desc;
# 2. 查询占用bufferpool较多的表
select object_schema,object_name,allocated,data
from sys.innodb_buffer_stats_by_table order by allocated limit 10;
# 3. 查看表的全表扫描情况
select * from sys.statements_with_full_table_scans where db='dbname';
```

**语句相关**

```sql
#1. 监控SQL执行的频率
select db,exec_count,query from sys.statement_analysis
order by exec_count desc;
#2. 监控使用了排序的SQL
select db,exec_count,first_seen,last_seen,query
from sys.statements_with_sorting limit 1;
#3. 监控使用了临时表或者磁盘临时表的SQL
select db,exec_count,tmp_tables,tmp_disk_tables,query
from sys.statement_analysis where tmp_tables>0 or tmp_disk_tables >0
order by (tmp_tables+tmp_disk_tables) desc;
```

**IO相关**

```sql
#1. 查看消耗磁盘IO的文件
select file,avg_read,avg_write,avg_read+avg_write as avg_io
from sys.io_global_by_file_by_bytes order by avg_read limit 10;
```

**Innodb** **相关**

```
#1. 行锁阻塞情况
select * from sys.innodb_lock_waits;
```

